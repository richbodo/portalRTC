)]}'
{"version":3,"sources":["fds:streams/lib/ev.js","fds:streams/lib/client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gB;AACA,kB;AACA,oB;;AAEA,oC;AACA,wD;;AAEA,yB;AACA,sD;AACA,0C;AACA,kC;AACA,O;AACA,K;AACA,I;;AAEA,0C;AACA,0B;AACA,2B;AACA,K;AACA,mC;AACA,I;;AAEA,8C;AACA,+C;AACA,sC;AACA,kD;AACA,O;AACA,I;;AAEA,kE;AACA,yB;AACA,oD;AACA,uC;AACA,K;AACA,I;;AAEA,gE;AACA,gC;AACA,I;AACA,C;;AAEA,S;;;;;;;;;;;;;;;;;;ACzCA,4D;AACA,gB;;AAEA,e;AACA,c;AACA,iB;;AAEA,wC;AACA,yB;AACA,uC;AACA,yB;AACA,K;AACA,6C;AACA,wB;AACA,G;;AAEA,sC;AACA,oC;AACA,G;;AAEA,kB;AACA,oC;;AAEA,4B;AACA,mB;AACA,8C;AACA,G;AACA,wE;;AAEA,mB;AACA,qB;;AAEA,wB;AACA,yB;;AAEA,yB;;AAEA,+B;AACA,6B;AACA,yC;AACA,kC;AACA,yB;AACA,8C;AACA,sC;AACA,W;AACA,2B;AACA,c;AACA,yB;AACA,qD;AACA,qC;AACA,6C;AACA,O;AACA,K;AACA,K;;;AAGA,+E;AACA,sE;AACA,6B;AACA,mB;AACA,+B;AACA,G;;AAEA,+D;;AAEA,+B;AACA,mB;AACA,gE;AACA,Y;AACA,oC;AACA,K;AACA,I;;AAEA,iC;AACA,wB;AACA,I;AACA,C;;AAEA,gD","file":"/packages/fds_streams.js","sourcesContent":["function _EV() {\n  var self = this;\n  var handlers = {};\n\n  self.emit = function emit(event) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if(handlers[event]) {\n      for(var lc=0; lc<handlers[event].length; lc++) {\n        var handler = handlers[event][lc];\n        handler.apply(this, args);\n      }\n    }\n  };\n\n  self.on = function on(event, callback) {\n    if(!handlers[event]) {\n      handlers[event] = [];\n    }\n    handlers[event].push(callback);\n  };\n\n  self.once = function once(event, callback) {\n    self.on(event, function onetimeCallback() {\n      callback.apply(this, arguments);\n      self.removeListener(event, onetimeCallback);\n    });\n  };\n\n  self.removeListener = function removeListener(event, callback) {\n    if(handlers[event]) {\n      var index = handlers[event].indexOf(callback);\n      handlers[event].splice(index, 1);\n    }\n  };\n\n  self.removeAllListeners = function removeAllListeners(event) {\n    handlers[event] = undefined;\n  };\n}\n\nEV = _EV;","Meteor.Stream = function Stream(name, _callback, _options) {\n  EV.call(this);\n\n  var callback;\n  var options;\n  var connection;\n\n  if (typeof _callback === 'function') {\n    callback = _callback;\n    if (typeof _options === 'object') {\n      options = _options;\n    }\n  } else if (typeof _callback === 'object') {\n    options = _callback;\n  }\n\n  if (options && options.connection) {\n    connection = options.connection;\n  }\n\n  var self = this;\n  var streamName = 'stream-' + name;\n\n  var collectionOptions = {}\n  if (connection) {\n    collectionOptions.connection = connection;\n  }\n  var collection = new Meteor.Collection(streamName, collectionOptions);\n\n  var subscription;\n  var subscriptionId;\n\n  var connected = false;\n  var pendingEvents = [];\n\n  self._emit = self.emit;\n\n  collection.find({}).observe({\n    \"added\": function(item) {\n      if(item.type == 'subscriptionId') {\n        subscriptionId = item._id;\n        connected = true;\n        pendingEvents.forEach(function(args) {\n          self.emit.apply(self, args);\n        });\n        pendingEvents = [];\n      } else {\n        var context = {};\n        context.subscriptionId = item.subscriptionId;\n        context.userId = item.userId;\n        self._emit.apply(context, item.args);\n      }\n    }\n  });\n\n\n  // By using Meteor.subscribe, Meteor.call etc. we use the default connection,\n  // if a connection was specified in the options we use that instead.\n  var ddpConnection = Meteor;\n  if (connection) {\n    ddpConnection = connection;\n  }\n\n  subscription = ddpConnection.subscribe(streamName, callback);\n\n  self.emit = function emit() {\n    if(connected) {\n      ddpConnection.call(streamName, subscriptionId, arguments);\n    } else {\n      pendingEvents.push(arguments);\n    }\n  };\n\n  self.close = function close() {\n    subscription.stop();\n  };\n}\n\n_.extend(Meteor.Stream.prototype, EV.prototype);\n"]}